import numpy as np
import matplotlib as plt
from math import *
class Plaintext:
  """Class with different computations for a plaintext object
  """

  def __init__(self, pslots):
    """
    slots: 1D array
    """

    self.slots = np.array(pslots)
    self.num_slots = len(pslots)

  def __str__(self):
    return str(self.slots)

  def add(self, other_plain):
    """Method computes the sum of two plaintext objects
  Returns:
    Plaintext sum of self and other_plain
  """

    result = self.slots + other_plain.slots
    result1 = Plaintext(result)
    return result1

  def mul(self, other_plain):
    """Method computes the multiplication of two plaintext objects
  Returns:
    Plaintext product of self and other_plain
  """

    multresult = self.slots * other_plain.slots
    multresult1 = Plaintext(multresult)
    return multresult1

  def rotate(self, index):
    """Method computes the rotation of an object for a specific index
  Args:
    index: number of slots to rotate by
  Returns:
    Rotated plaintext object
    ex: rotating [1,2,3,4] by 1 returns [2,3,4,1]
  """

    test = np.roll(self.slots,-1* index)
    test1 = Plaintext(test)
    return test1
parameters = {
            'c_i' : 4,
            'w_i' : 4,
            'h_i' : 4,
            'k_i' : 2,
            'f_h': 3,
            'f_w': 3,
            'c_o' : 4,
            'k_o' : 2,
            'h_o' : 4,
            'w_o' : 4,
            't_i' : 1,
            't_o' : 1

}
k_i = parameters['k_i']
h_i = parameters['h_i']
w_i = parameters['w_i']
c_i = parameters['c_i']
f_h = parameters['f_h']
f_w = parameters['f_w']
c_o = parameters['c_o']
k_o = parameters['k_o']
h_o = parameters['h_o']
w_o = parameters['w_o']
t_i = parameters['t_i']
t_o = parameters['t_o']
def mult_pack(A, parameters):
    """
    Parameters:
        A (numpy.ndarray): Input tensor 
        h_i : Height 
        w_i : Width 
        c_i: Depth 
        k_i: Input gap
        t_i
    """
    # Initialize the output tensor A' with zeros
    A_prime = np.zeros((k_i * h_i, k_i * w_i, t_i))

    # Fill the A_prime tensor according to the given formula
    for i3 in range(k_i * h_i):  # Outer tensor height dimension
        for i4 in range(k_i * w_i):  # Outer tensor width dimension
            for i5 in range(t_i):  # Channel dimension after packing
                # Map indices from A to A' based on the input gap
                orig_i3 = i3 // k_i
                orig_i4 = i4 // k_i
                orig_i5 = ((k_i**2)*i5) + k_i * (i3 % k_i) + (i4 % k_i)

                # Place the value into A' only if the condition is satisfied
                if orig_i5 < c_i:  # Ensure the channel index is valid
                    A_prime[i3, i4, i5] = A[orig_i3, orig_i4, orig_i5]

    print(f"Multiplexed tensor A' shape: {A_prime.shape}")
    print(A_prime)
    return A_prime.ravel().astype(int)



# Example usage
h_i, w_i, c_i = 2, 2, 4  # Example dimensions of input tensor A
k_i = 2  # Input gap (stride for multiplexing)
t_i = 1

input_h = 2
input_w = 2
input_c = 4

input_image = np.array([[[i*input_c*input_w + j*input_c + k+1 for k in range(input_c)]for j in range(input_w)]for i in range(input_h)])
print(input_image)

def transform(input_image, input_height, input_width, input_channels):
    return input_image.transpose(2, 0, 1).reshape(input_height, input_width, input_channels)

# Initialize an example tensor A with random values
A = transform(input_image, input_h, input_w, input_c)
print(A)

print("Original tensor A shape:", A.shape)
print(input_image)

# Compute the multiplexed tensor A'
A_prime = mult_pack(A, parameters)

print("1D Vector:", A_prime)

def SumSlots(ct_a, m, p):
    """
    SumSlots algorithm implementation using only add, multiply, and rotate.
    Args:
        ct_a (Plaintext): Input ciphertext.
        m (int): Number of added slots
        p (int): Gap
    
    """
    ct_b = [ct_a]

    for j in range(1, int(np.log2(m)) + 1):  # Inclusive loop
        rotated = ct_b[j - 1].rotate(2**(j - 1) * p)
        ct_b.append(ct_b[j - 1].add(rotated))  

    ct_c = ct_b[int(np.log2(m))]

    for j in range(0, int(np.log2(m))):  # Exclusive loop
        if (m // (2**j)) % 2 == 1:
            rotation_distance = (m // (2**(j + 1))) * 2**(j + 1) * p
            rotated = ct_b[j].rotate(rotation_distance)
            ct_c = ct_c.add(rotated)  

    return ct_c #return ciphertext


# ex:
ct_a = Plaintext([1, 2, 3, 4, 5, 6, 7, 8])  # Example slots
m = 4  # Number of slots
p = 2  # Gap

# Compute SumSlots
result = SumSlots(ct_a, m, p)
print("Result:", result)

def U_prime(U, i1, i2, i, parameters):
    """
    Creates the multiplexed shifted weight tensor U'
    
    Args:
        U: Original  tensor of shape (fh, fw, ci, co)
        i1: Index for filter height dimension
        i2: Index for filter width dimension
        i: Index for output channel dimension
        params: Dictionary containing parameters ki, hi, wi, ci
    
    Returns:
        Tensor U'(i1,i2,i) of shape (ki*hi, ki*wi, ti)
    """
    
    fh, fw, ci, co = U.shape
    
    # Initialize the output tensor with zeros
    result = np.zeros((k_i * h_i, k_i * w_i), dtype=object)
    
    # Fill the tensor according to the conditions
    for i3 in range(k_i * h_i):
        for i4 in range(k_i * w_i):
            for i5 in range(t_i):
            # Check all conditions (with i5=0)
                cond1 = ((k_i**2)*i5) + k_i * (i3 % k_i) + i4 % k_i >= c_i
                cond2 = (i3 // k_i) - (fh - 1)//2 + i1 not in range(h_i)
                cond3 = (i4 // k_i) - (fw - 1)//2 + i2 not in range(w_i)
            
                if cond1 or cond2 or cond3:
                    result[i3, i4] = 0
                else:
                # Calculate indices for the original tensor U
                    u_idx = (i1, i2, ((k_i**2)*i5) + k_i * (i3 % k_i) + i4 % k_i, i)
                    result[i3, i4] = U[u_idx]
                
    return result

def mult_wgt(U, i1, i2, i, parameters):
    """
    Implements the simplified MultWgt function with ti=1 and i5=0.
    
    Args:
        U: Weight tensor (fh, fw, ci, co)
        i1: Index for filter height 
        i2: Index for filter width 
        i: Index for output channel 
        params: Dictionary containing parameters (ki, hi, wi, ci)
    
    Returns:
        Vector of U'(multiplexed shifted weight tensor)
    """
    
    # Create the multiplexed shifted weight tensor
    multiplexed = U_prime(U, i1, i2, i, parameters)
    
    # flatten the tensor 
    return multiplexed.flatten()
def Vector_S(prime):
    return prime.flatten()
def S_prime(parameters, i):
    S_prime = np.zeros((k_o*h_o, k_o*w_o, t_o), dtype=int)

    for i3 in range(k_o*h_o):
        for i4 in range(k_o*w_o):
            for i5 in range(t_o):
                if ((k_o**2)*i5) + k_o * (i3 % k_o) + i4 % k_o ==i:
                    S_prime[i3, i4, i5] = 1
                else:
                    S_prime[i3, i4, i5] = 0
    print(S_prime)
    return(Plaintext(Vector_S(S_prime)))


k_o = 2
h_o = 4 #2
w_o = 4 #2
c_o = 4
t_o = c_o // (k_o **2)
i = 0


selecting_tensor = S_prime(parameters, i)
print(selecting_tensor)

def weightU(fh, fw, ci, co, low=0, high=10):
    weightU = np.random.randint(low, high, size=(fh, fw, ci, co))
    return weightU

def multConv(ct_aprime, U, parameters):
    num_slots = len(ct_aprime.slots)
    zero_slots = np.zeros(num_slots)
    ct_zero = Plaintext(zero_slots)
    ct_d = ct_zero
    ct_prime = {}
    for i1 in range(f_h):
        for i2 in range(f_w):
            rotation = k_o**2 * ((i1 - (f_h - 1) // 2) // 2) + k_o * ((i2 - (f_w - 1) //2 ) // 2)
            ct_prime[(i1, i2)] = Plaintext(ct_aprime.rotate(rotation).slots.flatten())
    for i in range(c_o):
        ct_b = ct_zero
        for i1 in range(f_h):
            for i2 in range(f_w):
                weight = mult_wgt(U, i1, i2, i, parameters).flatten()
                weight_p = Plaintext(weight)
                ct_b = ct_b.add(ct_prime[(i1, i2)].mul(weight_p))
        ct_c = SumSlots(ct_b, k_o, 1)
        ct_c = SumSlots(ct_c, k_o, k_o * w_o)
        ct_c = SumSlots(ct_c, 1, k_o**2 * h_o*w_o)
        rot = -(((i // k_o**2) * k_o**2 * h_o * w_o) + (((i % (k_o**2)) // k_o) * k_o * w_o) + (i % k_o))
        print(ct_c.slots.shape)
        print(((S_prime(parameters, i))).slots.shape)
        print(k_o, h_o, w_o, c_o, i)
        ct_d = ct_d.add(ct_c.rotate(rot).mul(S_prime(parameters, i)))
    return ct_d

input = np.array([[[i*c_i*w_i + j*c_i + k+1 for k in range(c_i)]for j in range(w_i)]for i in range(h_i)])
ct_a = transform(input, h_i, w_i, c_i)
ct_aprime = Plaintext([mult_pack(ct_a, parameters)])
U = weightU(f_h, f_w, c_i, c_o, low=0,high=10)
ct_d = multConv(ct_aprime, U, parameters)

print(ct_D)
